// Code generated by MockGen. DO NOT EDIT.
// Source: ./client.go

// Package kafka is a generated GoMock package.
package kafka

import (
	context "context"
	tls "crypto/tls"
	reflect "reflect"

	kafka "github.com/segmentio/kafka-go"
	sasl "github.com/segmentio/kafka-go/sasl"
	gomock "github.com/golang/mock/gomock"
)

// Mockwriter is a mock of writer interface.
type Mockwriter struct {
	ctrl     *gomock.Controller
	recorder *MockwriterMockRecorder
}

// MockwriterMockRecorder is the mock recorder for Mockwriter.
type MockwriterMockRecorder struct {
	mock *Mockwriter
}

// NewMockwriter creates a new mock instance.
func NewMockwriter(ctrl *gomock.Controller) *Mockwriter {
	mock := &Mockwriter{ctrl: ctrl}
	mock.recorder = &MockwriterMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *Mockwriter) EXPECT() *MockwriterMockRecorder {
	return m.recorder
}

// Close mocks base method.
func (m *Mockwriter) Close() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close")
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close.
func (mr *MockwriterMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*Mockwriter)(nil).Close))
}

// WriteMessages mocks base method.
func (m *Mockwriter) WriteMessages(ctx context.Context, msgs ...kafka.Message) error {
	m.ctrl.T.Helper()
	varargs := []any{ctx}
	for _, a := range msgs {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "WriteMessages", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// WriteMessages indicates an expected call of WriteMessages.
func (mr *MockwriterMockRecorder) WriteMessages(ctx any, msgs ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]any{ctx}, msgs...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WriteMessages", reflect.TypeOf((*Mockwriter)(nil).WriteMessages), varargs...)
}

// Mockclient is a mock of client interface.
type Mockclient struct {
	ctrl     *gomock.Controller
	recorder *MockclientMockRecorder
}

// MockclientMockRecorder is the mock recorder for Mockclient.
type MockclientMockRecorder struct {
	mock *Mockclient
}

// NewMockclient creates a new mock instance.
func NewMockclient(ctrl *gomock.Controller) *Mockclient {
	mock := &Mockclient{ctrl: ctrl}
	mock.recorder = &MockclientMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *Mockclient) EXPECT() *MockclientMockRecorder {
	return m.recorder
}

// BuildWriter mocks base method.
func (m *Mockclient) BuildWriter(broker []string, compression kafka.Compression, saslMechanism sasl.Mechanism, tlsConfig *tls.Config) writer {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BuildWriter", broker, compression, saslMechanism, tlsConfig)
	ret0, _ := ret[0].(writer)
	return ret0
}

// BuildWriter indicates an expected call of BuildWriter.
func (mr *MockclientMockRecorder) BuildWriter(broker, compression, saslMechanism, tlsConfig any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BuildWriter", reflect.TypeOf((*Mockclient)(nil).BuildWriter), broker, compression, saslMechanism, tlsConfig)
}

// CreateTopicIfNotExist mocks base method.
func (m *Mockclient) CreateTopicIfNotExist(broker []string, topic string, mechanism sasl.Mechanism, tlsConfig *tls.Config, entries []TopicConfigEntry) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateTopicIfNotExist", broker, topic, mechanism, tlsConfig, entries)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateTopicIfNotExist indicates an expected call of CreateTopicIfNotExist.
func (mr *MockclientMockRecorder) CreateTopicIfNotExist(broker, topic, mechanism, tlsConfig, entries any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateTopicIfNotExist", reflect.TypeOf((*Mockclient)(nil).CreateTopicIfNotExist), broker, topic, mechanism, tlsConfig, entries)
}
