package bulk

import (
	"sort"
	"strings"
)

// FCoalgebra is one JSON node builder.
// F-coalgeras accepting zero amount of childs are primitive JSONs (constructors)
// arbitrary F-coalgebra may constructs JSON with N childs passed as strings
// if it unable to do it, it should panic
type FCoalgebra func([]string) string

// GenerationRules is just a map of child count to F-coalgebras which accepts that count of childs
// you should care about arity of F-coalgebras
type GenerationRules map[uint][]FCoalgebra

var (
	// see example of default generation rules
	DefaultGenerationRules GenerationRules = map[uint][]FCoalgebra{
		0: {numberConstructor, stringConstructor, arrayConstructor},
		1: {fCoalgebraJSONA, fCoalgebraJSONB, arrayConstructor},
		2: {fCoalgebraJSONC, arrayConstructor},
		3: {arrayConstructor},
	}

	// this rules do not generate collisions like 0 == "0"
	WithoutCollisionGenerationRules GenerationRules = map[uint][]FCoalgebra{
		0: {numberConstructor, arrayConstructor},
		1: {fCoalgebraJSONB, arrayConstructor},
		2: {fCoalgebraJSONC, arrayConstructor},
		3: {arrayConstructor},
	}
)

type JSONGenerator struct {
	generationRules GenerationRules
}

func checkLength(ch []string, l int) {
	if len(ch) != l {
		panic("Invalid number of children")
	}
}

// F-coalgebras
func numberConstructor(nest []string) string {
	checkLength(nest, 0)
	return "0"
}
func stringConstructor(nest []string) string {
	checkLength(nest, 0)
	return "\"0\""
}
func arrayConstructor(nest []string) string {
	// this constructor is of arbitrary arity
	return "[" + strings.Join(nest, ",") + "]"
}
func fCoalgebraJSONA(nest []string) string {
	checkLength(nest, 1)
	return "{\"x\":0,\"nest\":" + nest[0] + "}"
}
func fCoalgebraJSONB(nest []string) string {
	checkLength(nest, 1)
	return "{\"x\":\"0\",\"nest\":" + nest[0] + "}"
}
func fCoalgebraJSONC(nest []string) string {
	checkLength(nest, 2)
	return "{\"x\":\"0\",\"nest1\":" + nest[0] + ",\"nest2\":" + nest[1] + "}"
}

// enumerate all jsons generated by f-coalgebra rules and zero argument constructors
// this is needed because of two things:
//  1. use-case where json is primary key or part of the primary key in database
//  2. we would like to check as much nested collisions as we can (so 122 and "122" are used)
//
// note, that result length of array may differ with 'count' parameter, because of not having zero-arity constructors,
// or not having non-zero-arity constructors
// the algorithm is deterministic with no side effects
func (j *JSONGenerator) generateSequence(count int) []string {
	rules := j.generationRules
	if rules == nil {
		rules = DefaultGenerationRules
	}
	if count < 0 {
		panic("arrays cannot be negative length")
	}

	// generate null arity constructors
	constructorRules, ok := rules[0]
	if !ok {
		// no zero-arity constructors specified in rules -- safely return empty result
		return []string{}
	}
	var result []string
	for _, rule := range constructorRules {
		result = append(result, rule([]string{}))
	}

	// detemining order of arity iteration
	var arities []uint
	for arity := range rules {
		if arity == 0 {
			continue // ignore zero-arity constructors, they don't increase json height
		}
		arities = append(arities, arity)
	}
	sort.Slice(arities, func(i, j int) bool { return arities[i] < arities[j] })

	currentLimit := 0
	for {
		// [prevLimit, currentLimit) interval distinguishes trees of exactly "level - 1" size
		prevLimit := currentLimit
		currentLimit = len(result)
		// for constructor count do recursive generation
		for _, arity := range arities {
			for _, constructor := range rules[arity] {
				// at least one argument should be indexed in interval [prevLimit, currentLimit) to satisfy monotonic height increase
				// this complex condition is for uniqueness of jsons used as primary key
				var combinatorialRecursion func(subtreeList []string, valid bool)
				combinatorialRecursion = func(subtreeList []string, valid bool) {
					if uint(len(subtreeList)) == arity {
						if !valid {
							panic("sequence should be valid") // never happen
						}
						// we can commit this combination of subtrees
						result = append(result, constructor(subtreeList))
						return
					}
					if uint(len(subtreeList))+1 == arity && !valid {
						// special case of else branch for optimization: forces to take tree of height h - 1
						// if previous selections does not made it
						for _, subtree := range result[prevLimit:currentLimit] {
							if len(result) >= count {
								return
							}
							combinatorialRecursion(append(subtreeList, subtree), true)
						}
					} else {
						// consider only subtrees less than current height
						for id, subtree := range result[:currentLimit] {
							if len(result) >= count {
								return
							}
							combinatorialRecursion(append(subtreeList, subtree), valid || id >= prevLimit)
						}
					}
				}
				// launch combinatorial recursion
				if len(result) >= count {
					return result
				}
				combinatorialRecursion([]string{}, false)
			}
		}
		// no changes since last cycle: no non-zero-arity constructors
		if prevLimit == currentLimit {
			return result
		}
	}
}

// NewJSONGenerator creates JSONGenerator with generation rules
// if generationRules rules are nil, default will be used
func NewJSONGenerator(generationRules GenerationRules) *JSONGenerator {
	return &JSONGenerator{
		generationRules: generationRules,
	}
}
